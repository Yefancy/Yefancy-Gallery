opt_mainVis = {
    sakura_path: [[232.0, 12.5], [247.0, 13.5], [264.5, 11.0], [281.5, 13.5], [300.5, 9.5], [315.5, 11.0], [332.5, 16.5], [350.5, 21.0], [363.5, 31.0], [372.5, 45.0], [379.5, 72.0], [379.5, 89.0], [377.0, 112.0], [379.5, 132.5], [378.5, 150.0], [371.0, 166.5], [371.0, 194.0], [348.0, 221.5], [317.5, 246.0], [281.5, 255.5], [260.0, 251.0], [232.0, 235.5], [204.0, 226.0], [194.0, 206.0], [178.5, 186.0], [181.5, 170.0], [180.5, 157.0], [177.0, 137.5], [180.5, 108.0], [174.5, 88.5], [177.0, 61.0], [177.0, 54.0], [187.5, 41.0], [193.5, 29.0], [212.0, 17.0], [191.5, 94.0], [215.5, 96.5], [237.0, 94.0], [257.5, 98.5], [267.0, 94.0], [298.0, 96.5], [322.5, 94.0], [352.5, 100.5], [195.0, 167.0], [213.5, 164.0], [239.0, 170.5], [269.0, 167.0], [282.5, 162.0], [300.5, 170.5], [318.0, 169.0], [337.0, 167.0], [356.0, 170.5], [448.5, 94.0], [451.5, 68.5], [451.5, 50.5], [468.0, 33.0], [489.0, 14.0], [523.0, 11.5], [540.5, 10.0], [576.5, 13.0], [594.0, 13.0], [622.0, 16.0], [637.0, 32.0], [650.5, 59.5], [648.0, 81.5], [650.5, 99.0], [651.5, 122.5], [647.5, 144.0], [651.5, 165.5], [644.0, 198.0], [623.0, 215.5], [447.5, 112.0], [452.0, 140.5], [447.5, 164.0], [455.5, 187.0], [468.5, 205.5], [479.5, 231.5], [505.0, 245.5], [530.0, 248.5], [556.5, 254.5], [583.0, 244.0], [607.5, 236.5], [465.0, 96.0], [491.5, 99.5], [521.5, 94.0], [546.5, 96.0], [571.0, 92.0], [596.5, 97.5], [623.5, 94.0], [637.0, 99.5], [466.0, 168.5], [486.5, 166.0], [513.0, 171.5], [533.0, 164.0], [570.0, 171.5], [592.5, 166.0], [619.5, 168.5], [632.0, 166.0], [166.5, 388.0], [187.0, 374.0], [203.5, 368.5], [222.5, 354.0], [245.5, 346.0], [263.5, 333.5], [281.0, 328.0], [302.0, 317.0], [326.0, 314.0], [354.0, 303.0], [385.0, 300.5], [398.5, 296.0], [416.0, 239.0], [410.5, 257.5], [416.0, 281.0], [412.5, 301.5], [429.5, 297.0], [464.0, 300.5], [484.0, 311.0], [514.5, 317.0], [544.0, 327.5], [557.5, 337.5], [582.5, 348.0], [256.5, 362.5], [279.0, 375.5], [302.0, 379.0], [332.5, 392.5], [363.5, 396.5], [387.0, 401.5], [435.5, 410.5], [458.5, 419.0], [488.0, 419.0], [523.5, 426.5], [561.5, 426.5], [597.0, 432.5], [628.0, 430.5], [651.5, 437.5], [570.5, 361.5], [549.0, 373.0], [520.0, 380.5], [483.5, 392.0], [443.5, 399.5], [408.5, 410.0], [369.0, 414.5], [347.5, 420.0], [319.5, 428.0], [302.0, 439.0], [276.0, 456.5], [266.5, 473.0], [246.0, 494.5], [241.5, 509.5], [227.0, 531.0], [223.5, 557.0], [213.5, 592.0], [216.5, 608.5], [208.5, 631.5], [201.5, 660.0], [200.5, 675.5], [205.0, 700.5], [200.5, 723.0], [209.5, 746.5], [205.0, 769.0], [200.5, 786.5], [416.0, 361.0], [411.5, 392.5], [416.0, 428.0], [411.5, 445.5], [421.0, 477.5], [408.5, 504.5], [263.0, 501.5], [282.0, 504.5], [310.0, 498.5], [328.0, 504.5], [356.0, 508.5], [386.0, 501.5], [436.0, 504.5], [457.0, 501.5], [472.0, 500.5], [492.5, 505.0], [522.0, 500.5], [542.0, 505.0], [573.5, 500.5], [596.5, 505.0], [231.5, 578.5], [253.5, 583.0], [285.5, 578.5], [318.0, 583.0], [333.0, 578.5], [356.0, 583.0], [391.5, 578.5], [420.0, 580.5], [444.0, 585.0], [466.5, 580.5], [494.0, 585.0], [525.5, 577.0], [546.0, 580.5], [577.0, 577.0], [607.5, 580.5], [415.0, 519.0], [409.5, 544.5], [415.0, 566.0], [409.5, 594.0], [418.5, 622.0], [409.5, 655.0], [220.5, 657.0], [244.0, 662.0], [277.5, 657.0], [309.5, 664.5], [342.0, 662.0], [367.0, 664.5], [398.0, 662.0], [423.5, 663.0], [442.0, 660.0], [467.5, 665.5], [493.5, 658.0], [518.0, 665.5], [549.5, 658.0], [568.0, 660.0], [590.0, 656.5], [619.5, 660.0], [631.5, 656.5], [38.0, 1.0], [53.5, 12.0], [59.0, 19.5], [77.0, 29.0], [87.5, 46.0], [97.5, 62.0], [102.0, 75.5], [100.0, 91.0], [102.0, 104.0], [92.0, 124.0], [89.0, 141.0], [75.5, 151.5], [60.0, 174.5], [34.0, 189.0], [28.5, 199.5], [11.0, 206.5], [1.0, 212.5], [790.5, 3.0], [771.0, 13.5], [757.5, 27.5], [742.0, 38.0], [738.0, 59.0], [725.5, 74.0], [719.5, 97.5], [732.0, 118.5], [742.0, 138.5], [754.5, 149.0], [762.0, 167.0], [782.5, 180.0], [792.5, 193.0], [813.0, 200.0], [828.0, 213.0], [39.0, 504.5], [41.5, 484.5], [36.0, 461.0], [41.5, 435.5], [36.0, 406.5], [41.5, 384.0], [36.0, 357.5], [41.5, 341.5], [41.5, 324.5], [50.5, 309.0], [54.5, 291.5], [66.0, 275.5], [84.0, 264.0], [95.0, 262.5], [113.5, 278.0], [118.0, 290.5], [130.0, 306.5], [135.5, 326.5], [143.5, 347.5], [140.5, 372.5], [148.0, 393.5], [145.5, 415.5], [150.5, 442.0], [143.5, 464.0], [145.5, 488.5], [140.5, 513.0], [137.5, 539.5], [130.0, 554.5], [127.0, 574.5], [116.0, 592.5], [112.0, 618.5], [102.5, 637.5], [96.0, 656.5], [97.0, 663.5], [83.5, 678.5], [80.0, 689.5], [68.5, 707.5], [63.0, 726.0], [44.0, 744.0], [42.0, 758.5], [24.5, 778.0], [789.5, 511.0], [794.0, 487.0], [789.5, 468.0], [794.0, 441.5], [789.5, 410.0], [794.0, 376.5], [785.0, 341.0], [785.0, 320.5], [779.5, 297.5], [771.5, 274.5], [742.5, 263.0], [726.5, 268.0], [720.5, 276.0], [703.5, 295.5], [699.0, 312.0], [688.5, 335.0], [688.5, 361.5], [682.0, 387.0], [685.0, 409.5], [677.5, 437.5], [685.0, 472.0], [682.0, 490.5], [682.0, 509.5], [695.0, 537.0], [701.0, 576.0], [711.0, 597.5], [719.0, 630.0], [732.0, 654.0], [742.5, 685.0], [760.0, 706.0], [770.0, 733.5], [786.5, 753.0], [801.0, 780.0]],
    svg: '#mainVis',
    road: '#roadSvg',
    defaultSpeed: 4,
    variantSpeed: 2,
    color_1: '#3DB6C7',
    color_2: '#3DC7AE',
    color_3: '#E2B094',
    debug: !IsPC()
}

let stage_dd = 0
let cityDots = null
let sakura_petal = null
let sakura_left = null
let sakura_wuhan = null
let rotateSpeed = 1
let bridge_dot = null
$(document).ready(function () {
    //change color
    for (let i = 1; i <= 3; i++) {
        let color = opt_mainVis[`color_${i}`]
        $($(`#rayL${i} stop`).get(1)).css('stop-color', color);
        $($(`#rayM${i} stop`).get(1)).css('stop-color', color);
        $($(`#rayR${i} stop`).get(0)).css('stop-color', color);
        $($(`#city_wave_grad${i} stop`).get(1)).css('stop-color', color);
    }
    // let stage = -1
    let mainVis = d3.select(opt_mainVis.svg)
    let roadSvg = d3.select(opt_mainVis.road)
    let wordSvg = roadSvg.select('#word')
    let progressSvg = d3.select('#progress')
    let sakuraTree = d3.select('#sakuraTree')


    //////////////////////////////river anima
    let r1 = d3.select('#river_1')
    let r2 = d3.select('#river_2')
    let r3 = d3.select('#river_3')
    let f1 = 0.8
    let f2 = 1.5
    let f3 = 1.8
    let r1p = {x:0, y: 1051}
    let r2p = {x:-1920, y: 1035}
    let r3p = {x:0, y: 978}
    let frame = 0
    function yScale(t){
        if(t < 0.5) return d3.easeQuadInOut(2 * t)
        else return d3.easeQuadInOut(2- 2 * t)
    }
    let riverAnima = ()=>{
        if(stage_dd != 5) {
            frame++
            r1.attr('transform', `translate(${r1p.x}, ${r1p.y})`)
            r2.attr('transform', `translate(${r2p.x}, ${r2p.y})`)
            r3.attr('transform', `translate(${r3p.x}, ${r3p.y})`)
            // update
            if (frame )
            r1p.y = 1051 + f1 * (yScale(frame % 120 / 120) * 2 - 0.5)
            r2p.y = 1035 + f2 * (yScale(frame % 180 / 180) * 2 - 0.5)
            r3p.y = 978 + f3 * (yScale(frame % 150 / 150) * 2 - 0.5)

            r1p.x -= 0.4
            r2p.x += 0.3
            r3p.x -= 0.2
            if (r1p.x <= -1920) r1p.x = 0
            if (r2p.x >= 0) r2p.x = -1920
            if (r3p.x <= -1920) r3p.x = 0
            window.requestAnimationFrame(riverAnima)
        }
    }; riverAnima()
    ///////////////////////

    function stage_1(){
        stage_dd = 1
        console.log('stage_dd_1_enter')
        if (sakura_petal != null)
            sakura_petal.remove()
        let ip1 = d3.interpolateRgb(opt_sakura.startColor, opt_sakura.middleColor)
        let ip2 = d3.interpolateRgb(opt_sakura.middleColor, opt_sakura.endColor)

        let particles = []
        for (let i = 0; i < opt_mainVis.sakura_path.length * 3; i++) {
            let pos = opt_mainVis.sakura_path[Math.floor(Math.random() * opt_mainVis.sakura_path.length)]
            particles.push(new Particle())
            particles[i].reset(- Math.random() * 1920, - Math.random() * 1080, pos[0] + 545.5 + Math.random() * 40 - 20, pos[1] + 100 + Math.random() * 40 - 20, opt_mainVis.defaultSpeed + opt_mainVis.variantSpeed*Math.random(), Math.random() * 0.03 + 0.09)
        }

        let sakuraPetal = mainVis.select('#sakuraPetal');
        sakuraPetal.transition().duration(1000).attr('opacity', 1);
        sakura_petal = sakuraPetal.selectAll()
            .data(particles)
            .join('path')
            .attr('d', d=>opt_sakura.sakura_svg[Math.floor(Math.random()*12)])
            // .attr('opacity', 1)
            .attr('fill', d=>Math.random() > 0.5 ? ip2(Math.random()) : ip1(Math.random()))
            .attr('transform', d => {
                return `translate(${d.x},${d.y})scale(${d.scale}, ${d.scale})`
            });

        let skiping = false;
        sakuraPetal.selectChild('g')
            .on('click', ()=>{
                skiping = true
            });


        (function animloop() {
            let out = 0
            sakura_petal
                .attr('transform', d=>{
                    out += d.update(1)? 1 : 0
                    return `translate(${d.x},${d.y})scale(${d.scale}, ${d.scale})`
                })
            if (skiping) {
                stage_2()
                sakuraPetal.transition().duration(1000).attr('opacity', 0).remove()
                return
            } else {
                if (out > particles.length / 3 && stage_dd === 1){
                    stage_2()
                    sakuraPetal.transition().duration(1000).attr('opacity', 0).remove()
                }
                if (out === particles.length) {
                    sakura_petal.remove()
                    sakura_petal = null
                    console.log('stage_dd_1_exit')
                    return
                }
            }
            window.requestAnimationFrame(animloop);
        })();
    }
    opt_mainVis.stage1 = stage_1;

    function sakuraAnima() {
        let degree = 180
        if(sakura_left != null)
            sakura_left.remove()

        let ip1 = d3.interpolateRgb(opt_sakura.startColor, opt_sakura.middleColor)
        let ip2 = d3.interpolateRgb(opt_sakura.middleColor, opt_sakura.endColor)

        let particles = []
        for (let i = 0; i < 14; i++) {
            particles.push(new Particle())
            particles[i].reset(Math.random() * 300, Math.random() * 500, Math.random() * 800 - 150, 1100, (opt_mainVis.defaultSpeed + 2) * 0.2 + opt_mainVis.variantSpeed*0.5*Math.random(), Math.random() * 0.03 + 0.1)
            particles[i].opacity = 0
        }

        sakura_left = mainVis.select('#sakuraLeft').selectAll()
            .data(particles)
            .join('path')
            .attr('d', d=>opt_sakura.sakura_svg[Math.floor(Math.random()*12)])
            .attr('opacity', d=>d.opacity)
            .attr('fill', d=>Math.random() > 0.5 ? ip2(Math.random()) : ip1(Math.random()))
            .attr('transform', d => {
                return `translate(${d.x},${d.y})scale(${d.scale}, ${d.scale})`
            });

        let n5 = sakuraTree.select('#N5');

        (function anima_n5(){
            if(sakura_left == null) return
            n5.transition().duration(4000).delay(500)
                .attr('transform', 'rotate(5)')
                .on('end', ()=>{
                    n5.transition().duration(4000).delay(500)
                        .attr('transform', 'rotate(0)')
                        .on('end', ()=>anima_n5())
                })
        })();

        let n2 = sakuraTree.select('#N2');
        (function anima_n2(){
            if(sakura_left == null) return
            n2.transition().duration(3000)
                .attr('transform', 'rotate(1)')
                .on('end', ()=>{
                    n2.transition().duration(3000)
                        .attr('transform', 'rotate(-1)')
                        .on('end', ()=>anima_n2())
                })
        })();

        function animloop() {
            if(sakura_left == null) return
            sakura_left
                .attr('transform', d=>{
                    d.update(2)
                    return `translate(${d.x},${d.y})scale(${d.scale}, ${d.scale})`
                })
                .attr('opacity', d=>d.opacity)
            if(sakura_wuhan !== null) {
                sakura_wuhan.attr('transform',`translate(931 478)rotate(${degree},27.5,27.5)`)
                degree += rotateSpeed
            }

            window.requestAnimationFrame(animloop);
        }
        animloop()
    }

    function getDate(y) {
        if(y <= 720 && y >= 0) {
            let dur = 720 / (data_clean.weibo_date.length - 1)
            let index = Math.round(y / dur)
            return data_clean.weibo_date[index]
        }
        return null
    }

    let enableProgress = false
    let progress_bar = d3.select(progressSvg.selectAll('rect').nodes()[1])
    let progress_pin = progressSvg.select('#progressPin')
    let progress_bar_chart = progressSvg.select('#progressBarChart').selectAll('rect')
    let filter = 0 // 0-all 1-m 2-l 3-p
    let dragDate = null

    function updateBarChart(dragDate, callback){
        let op = 0.4
        let color1 = '#2D3444'
        let color2 = 'pink'
        if(dragDate) {
            progress_bar_chart.each(function(d, i){
                let index = data_clean.weibo_date.indexOf(dragDate)
                let bar = d3.select(this)
                let opacity = parseFloat(bar.attr('opacity'))
                if(i <= index) {
                    if(d3.active(this, 'in') === null) {
                        bar.interrupt('out')
                        bar.transition('in').duration(1000)
                            .attr('opacity', 1)
                            .attr('fill', color2)
                    }
                } else if (i >= index) {
                    if(d3.active(this, 'out') === null){
                        bar.interrupt('in')
                        bar.transition('out').duration(1000)
                            .attr('opacity', op)
                            .attr('fill', color1)
                    }

                }
            })
            return
        }
        let data = []
        let dur = 720 / (data_clean.weibo_date.length - 1)
        for (let i = 0; i < data_clean.weibo_date.length; i++) {
            let weibo_data = data_weibo[data_clean.weibo_date[i]]
            let set = new Set()
            if(filter == 0 || filter == 1) Object.keys(weibo_data[0]).forEach(key=>{set.add(key)})
            if(filter == 0 || filter == 2) Object.keys(weibo_data[1]).forEach(key=>{set.add(key)})
            if(filter == 0 || filter == 3) Object.keys(weibo_data[2]).forEach(key=>{set.add(key)})
            data.push(set.size)
        }

        if (progress_bar_chart.empty()) {
            progress_bar_chart = progress_bar_chart.data(data)
                .join('rect')
                .attr('rx', 3)
                .attr('ry', 3)
                .attr('x', 0)
                .attr('y', (d,i)=> - dur / 2 + 1 + dur * i)
                .attr('width', 0)
                .attr('height', dur / 2 - 1)
                .attr('fill', color1)
                .attr('opacity', op)
        }

        progress_bar_chart.data(data)
            .transition().duration(1000)
            .attr('width', d=>d*6)
            .on('end', callback)
    }

    function changeFilter(new_filter) {
        if(filter !== new_filter) {
            console.log(`change 2 ${new_filter}`)
            filter = new_filter

            updateBarChart()
            rayCity()
        }
    }

    let cards = []
    for (let i = 0; i < 4; i++) {
        cards.push(sakuraTree.select(`#S${i}`))
        cards[i].on('click', ()=>{
            changeFilter(i)
            cards[i].select('text').transition().style('fill', '#e2004f')
            cards.forEach(card=>{
                if(card !== cards[i]) {
                    card.select('text').transition().style('fill', '#212222')
                }
            })
        }).on('mouseover', function(){
            d3.select(this).attr('transform', 'translate(0 5)')
        }).on('mouseleave', function(){
            d3.select(this).attr('transform', null)
        })
    }

    function stage_2(){
        let shoudDelay = (opt_mainVis.debug || stage_dd == 5)
        if (parseFloat(wordSvg.attr('opacity')) === 0){
            wordSvg.transition().duration(6000).attr('opacity', 1)

            //wuhan sakura
            let wuhan = d3.select('#sakuraWuHan');
            wuhan.transition().duration(5000).ease(d3.easeCubicInOut)
                .attr('transform','translate(931 478)rotate(180,27.5,27.5)')
                .on('end', ()=>{sakura_wuhan = wuhan})

            //add city dots
            cityDots = roadSvg.select('#cityDots').selectAll()
                .data(data_city_dots)
                .join('circle')
                .attr('opacity', 0)
                .attr('cx', d=>d.cx)
                .attr('cy', d=>d.cy)
                .attr('r', 11)
                .attr('fill', '#1f2228')
                .transition().duration(6000)
                .attr('opacity', d=>d.name === '湘'? 0.4 : 1)

            //add line bg
            roadSvg.select('#cityDots').selectAll()
                .data(data_city_dots)
                .join('line')
                .attr('stroke', '#262B35')
                .attr('x1', 414)
                .attr('y1', 405)
                .attr('x2', 414)
                .attr('y2', 405)
                .transition().duration(1000).delay(1000)
                .attr('x2', (d,i)=>i * opt_cityBridge.dur + -354)
                .attr('y2', 833)

            //add bar
            roadSvg.select('#barBridge')
                .transition().duration(1500)
                .attr('opacity', 1)

            //add bridge
            let cityBridgeSvg = d3.select(opt_cityBridge.svg).append('g').attr('opacity', 0)
            let offsetX = 960 - (data_city_dots.length - 1) * opt_cityBridge.dur / 2
            let offsetY = 72

            cityBridgeSvg.append('line')
                .attr('stroke', 'white')
                .attr('stroke-width', 1)
                .attr('x1', 0)
                .attr('x2', 1920)
                .attr('y1', offsetY)
                .attr('y2', offsetY)

            bridge_dot = cityBridgeSvg.selectAll()
                .data(data_city_dots, d=>provincesMap[d.name])
                .join('circle')
                .attr('cx', (d, i)=> i * opt_cityBridge.dur + offsetX)
                .attr('cy', offsetY)
                .attr('r', opt_cityBridge.r)
                .attr('stroke', 'white')
                .attr('stroke-width', 1)
                .attr('fill', '#1a1b1e')


            cityBridgeSvg.selectAll()
                .data(data_city_dots, d=>provincesMap[d.name])
                .join('text')
                .attr('fill', 'white')
                .attr('text-anchor', 'middle')
                .attr('x', (d, i)=> i * opt_cityBridge.dur + offsetX)
                .attr('y', offsetY + 30)
                .text(d=>d.name)

            cityBridgeSvg
                .transition().duration(1500)
                .attr('opacity', 1)
        }
        else if(stage_dd == 5){
            d3.select('#cityBridgeSvg').transition().duration(1000)
                .attr('transform', 'translate(0 860)')
            d3.select('#river').transition().duration(2000)
                .attr('opacity', 1)
            d3.select('#roadSvg').transition().duration(2000)
                .attr('opacity', 1)
            d3.select('#progress').transition().duration(2000)
                .attr('opacity', 1)
            d3.select('#sakuraWuHan').transition().duration(2000)
                .attr('opacity', 1)
            stage_dd = 2
            riverAnima()
        }
        stage_dd = 2
        console.log('stage_dd_2_enter')

        setTimeout(()=>{
            progress_pin.call(d3.drag()
                .on('drag', function(e){
                    if (e.y < 720 && e.y > 0 && enableProgress) {
                        // progress_dots.attr('transform', `translate(0 ${e.y})`)
                        progress_bar.attr('height', e.y)
                        progress_pin.attr('transform', `translate(0 ${e.y})`)
                        let date = getDate(e.y)
                        if (date !== dragDate) {
                            dragDate = date
                            progress_pin.select('text').text(`20/${date}`)
                            updateBarChart(dragDate)
                        }
                    }
                })
                .on('end', function(e){
                    rayCity()
                }));
            // d3.select(progressSvg.selectAll('text').nodes()[0])
            //     .text(data_clean.weibo_date[0])
            // d3.select(progressSvg.selectAll('text').nodes()[1])
            //     .text(data_clean.weibo_date[data_clean.weibo_date.length-1])
            progressSvg.attr("display", null)
                .attr('opacity', 0)
                .transition().duration(1500)
                .attr('opacity', 1)
                .on('end',()=>{
                    if(dragDate == null)
                        dragDate = getDate(0)
                    progress_pin.select('text').text(`20/${dragDate}`)
                    updateBarChart(false, ()=>{
                        enableProgress = true
                    })
                    rayCity()
                })

            //navbar
            d3.select('#navbar').transition().duration(1000)
                .attr('opacity', 1)
        }, shoudDelay? 0 : 4000)
        sakuraAnima()
        let cityDots_grad = d3.select('#cityDots_grad')
        let bcf = ()=>{
            cityDots_grad.transition().duration(500).ease(d3.easeQuadInOut)
                .attr('r', '100%')
                .on('end', ()=>{
                    cityDots_grad.transition().duration(500).ease(d3.easeQuadInOut)
                        .attr('r', '50%')
                        .on('end', ()=>{
                            if(stage_dd === 2) {
                                bcf()
                            }
                        })
                })
        }; bcf()
    }

    opt_mainVis.stage2 = stage_2
    /////////////
    function Particle(){
    }

    Particle.prototype.update = function(mode){
        if (mode === 1) {
            if (this.x > 1920 || this.y > 1080) return true
            // if (this.y >= 1038) {
            //     this.y += (Math.random() > 0.8) ? Math.random() * 1 : 0
            //     this.x += 1.5
            //     return false
            // }
            let dx = this.destX - this.x
            let dy = this.destY - this.y
            let dist = Math.sqrt(dx * dx + dy * dy)
            let speed = this.speed
            if (dist < 300) {
                speed = (dist / 300) * this.speed
                speed = Math.max(speed, 0.01)
            }
            this.x += speed * this.vector.x;
            this.y += speed * this.vector.y;
            return false
        } else if(mode === 2){
            this.x += this.speed * this.vector.x;
            this.y += this.speed * this.vector.y;
            if(this.opacity !== 1) {
                this.opacity += 0.01
            }
            if (this.y >1035) {
                this.vector.x = 0.5
                this.vector.y = 0.2
            } else if (this.x > 500) {
                this.vector.x = - this.vector.x
            }
            if (this.y > 1100) {
                this.reset(Math.random() * 300, Math.random() * 500, Math.random() * 800 - 150, 1100, opt_mainVis.defaultSpeed * 0.2 + opt_mainVis.variantSpeed*0.5*Math.random(), Math.random() * 0.03 + 0.1)
                this.opacity = 0
            }
        }
    }

    Particle.prototype.reset = function(x, y, destX, destY, speed, scale){
        this.scale = scale
        this.x =  x;
        this.y = y;
        this.destX = destX
        this.destY = destY
        let dx = destX - this.x
        let dy = destY - this.y
        let directionAngle = Math.PI / 2 - Math.atan2(dx, dy)
        this.speed = speed;
        this.vector = {
            x: Math.cos(directionAngle),
            y: Math.sin(directionAngle)
        }
    }
    ////////////////
    let rays = null
    let lastCities = null
    let lastWave = null

    function getFilterColor(cityName) {
        let color = filter
        if(filter == 0) {
            let colors = []
            for (let j = 0; j < 3; j++) {
                if (data_weibo[dragDate][j][cityName]) {
                    colors.push(j + 1)
                }
            }
            if (colors.length > 0) {
                color = colors[Math.floor(Math.random() * colors.length)]
            }
        }
        return color
    }

    function rayCity(){
        hidePin(1)
        let cities_name = Object.keys(getFilterData(filter, dragDate))
        lastCities = d3.map(cities_name, d=>provincesMap[d])
        rotateSpeed = lastCities.length * 0.3 + 0.8
        if (rays != null) {
            rays.remove()
            rays = null
            lastF = null
        }

        let f = function (parent, ray, i) {
            ray.attr('stroke', (city)=>{
                let color = getFilterColor(cities_name[i])
                return city < 16 ? `url(#rayL${color})` : city == 16 ? `url(#rayM${color})` : `url(#rayR${color})`
            })
                .attr('x1', city=>city * opt_cityBridge.dur + -354)
                .attr('y1', 833)
                .attr('x2', city=>city * opt_cityBridge.dur + -354)
                .attr('y2', 833)
                .transition().duration(1000 + 1000 * Math.random()).delay(Math.random()*500)
                .attr('x2', 414.01)
                .attr('y2', 405)
                .on('end', ()=>{
                    if(parent === rays && stage_dd == 2){
                        setTimeout(function (){f(parent, ray, i);},50)
                    }
                })
        }

        rays = roadSvg.select('#rayCities')
            .selectAll()
            .data(lastCities)
            .join('line');
        rays.each(function(ray, i){f(rays, d3.select(this), i)})



        bridge_dot.each(function(d){
            if (lastCities.indexOf(provincesMap[d.name]) != -1) {
                let f2 = () => {
                    let city = d3.select(this)
                    city.transition().duration(1500).ease(d3.easeQuadInOut)
                        .attr('fill', d=>{
                            return opt_mainVis[`color_${getFilterColor(d.name)}`]
                        })
                        .on('end', ()=>{
                            city.transition().duration(1500).ease(d3.easeQuadInOut)
                                .attr('fill', '#1a1b1e')
                                .on('end', ()=>{
                                    if (lastCities.indexOf(provincesMap[d.name]) != -1 && stage_dd == 2){
                                        f2()
                                    }
                                })
                        })
                };f2()
            }
        })

        cityDots.each(function(d){
            if (lastCities.indexOf(provincesMap[d.name]) != -1) {
                let city = d3.select(this)
                    .attr('fill', 'url(#cityDots_grad)')
                    .on('mouseover', (e,d)=>{
                        if(stage_dd !=2) return
                        let data = getFilterData(filter, dragDate)[d.name]
                        if(data) {
                            let index = data_city_dots.indexOf(d)
                            let content = ''
                            data.forEach(s=>{
                                content += ' ' + s
                            })
                            showPin(d.cx + 512, d.cy + 85,1, {0:d.name, 1:content, 2:`2020/${dragDate}`}, pin=>{
                                for (let i = 1; i <= 3; i++) {
                                    let flag = filter == i
                                    if(filter == 0 && data_weibo[dragDate][i - 1][d.name]){
                                        flag = true
                                    }
                                    d3.select(`#flowPin_1_icon_${i}`)
                                        .attr('fill',()=>flag? opt_mainVis[`color_${i}`] : '#999899')
                                }
                                data_weibo[dragDate]
                                pin.on('mouseleave', ()=>{
                                    hidePin(1)
                                    sakuraTree.select("#N1").transition().duration(2000)
                                        .attr('transform',`translate(0 0)scale(1)`)
                                    sakuraTree.select("#N4").transition().duration(2000)
                                        .attr('transform',`translate(0 0)scale(1)`)
                                })
                            })
                            let dur = Math.abs(index - 16)
                            sakuraTree.select("#N1").transition().duration(2000)
                                .attr('transform',`translate(${dur * -1} ${dur * 2})scale(${1 - dur * 0.0025})`)
                            sakuraTree.select("#N4").transition().duration(2000)
                                .attr('transform',`translate(${dur * 1} ${dur * -2})scale(${1 + dur * 0.0025})`)
                        }
                    })
            } else if(d3.select(this).attr('fill') !== '#1a1b1e'){
                d3.select(this).attr('fill', '#1a1b1e')
                    .on('mouseover', null)
            }
        })

        let toWave = []
        lastCities.forEach(city=>{
            let x = city * opt_cityBridge.dur + 170
            toWave.push(new Wave(x - 150 - Math.random() * 20, x, x + 150 + Math.random() * 20, 1080, 70 + Math.random() * 40, 0))
        })

        if(lastWave != null){
            lastWave.each(d=>d.out = true)
        }

        let wave = mainVis.select('#city_wave').selectAll()
            .data(toWave)
            .join('path')
            .attr('fill', (d,i)=>{
                return `url(#city_wave_grad${getFilterColor(cities_name[i])})`
            })

        let anima = ()=>{
            if (stage_dd == 2) {
                let oc = 0
                wave.attr('d', function (d, i){
                    oc += d.update()? 0 : 1
                    if (d.h == d.minH) {
                        d3.select(this).attr('fill', ()=>`url(#city_wave_grad${getFilterColor(cities_name[i])})`)
                    }
                    return d.getPath()
                })
                if (oc == toWave.length) {
                    wave.remove()
                } else {
                    window.requestAnimationFrame(anima)
                }
            } else {
                wave.transition().duration(2000)
                    .attr('opacity', 0)
                    .remove()
            }
        };anima()

        lastWave = wave
    }

    /////////////
    function Wave(x1, x2, x3, y, height, h){
        this.ox1 = x1
        this.ox2 = x2
        this.ox3 = x3

        this.x1 = x1
        this.y1 = y

        this.x2 = x2
        this.y2 = y

        this.x3 = x3
        this.y3 = y

        this.durL = 40 + Math.random() * 20
        this.vecL = 0.5
        this.vecR = -0.4
        this.durR = 50 + Math.random() * 20

        this.minH = 1
        this.h = h
        this.height = height
        this.vecH = 0.2
        this.vec2 = 0.015 - Math.random() * 0.005

        this.out = false
    }

    Wave.prototype.update = function (){
        if(this.out && this.h <= this.minH) {
            return false
        }

        if (this.x1 < this.durL + this.ox1 && this.x1 > this.ox1 - this.durL)
            this.x1 += this.vecL
        else {
            this.vecL *= -1
            this.x1 += this.vecL
        }

        if (this.x3 < this.durR + this.ox3 && this.x3 > this.ox3 - this.durR)
            this.x3 += this.vecR
        else {
            this.vecR *= -1
            this.x3 += this.vecR
        }

        this.h += this.vecH
        if(this.vecH > 0)
            this.vecH += this.vec2
        else
            this.vecH = Math.min(-0.2, this.vecH + this.vec2)
        if (this.h > this.height) {
            this.h = this.height
            this.vecH *= -1
        } else if (this.h < this.minH) {
            this.h = this.minH
            this.vecH = 0.2
        }

        let per = (this.h - this.minH) / (this.height - this.minH)
        if(this.vecH > 0) {
            this.x2 = this.x1 + per * (this.ox2 - this.x1)
        } else {
            this.x2 = this.x3 - per * (this.x3 - this.ox2)
        }

        return true;
    }



    Wave.prototype.getPath = function (){
        return `M${this.x1} ${this.y1} L${this.x2} ${this.y2 - this.h} Q${(this.x1 + this.x3 + 10 ) / 2 + (this.x3 - this.x1 - 10) / 2 * (1 - (this.h - this.minH) / (this.height - this.minH))} ${(this.y3 + this.y1) / 2} ${this.x3} ${this.y3}Z`
        // return `M${this.x1} ${this.y1} L${this.x2} ${y2} L${this.x3} ${this.y3} Z`
    }
    /////////////


    function stage_5(){
        console.log('stage_dd_5_enter')
        enableProgress = false
        stage_dd = 5
        if(sakura_left)
            sakura_left.remove()
        sakura_left=null

        d3.select('#river').transition().duration(1000)
            .attr('opacity', 0)
        d3.select('#roadSvg').transition().duration(1000)
            .attr('opacity', 0)
        d3.select('#progress').transition().duration(1000)
            .attr('opacity', 0)
        d3.select('#sakuraWuHan').transition().duration(1000)
            .attr('opacity', 0)
    }
    opt_mainVis.stage5 = stage_5

    registerScroll('#mainVis', (event, isDown) => {
        if (stage_dd === 2 && enableProgress) {
            let index = data_clean.weibo_date.indexOf(dragDate)
            if (isDown) {
                index++
            } else {
                index--
            }
            if (index < 0 || index >= data_clean.weibo_date.length || data_clean.weibo_date[index] === dragDate) {
                if (index >= data_clean.weibo_date.length) {
                    showGuideS(true, (e)=>e&&scrollTo(1))
                }
                // else if (index < 0) {
                //     showGuideS(false, (e)=>!e&&videoEnter())
                // }
                return
            }

            dragDate = data_clean.weibo_date[index]

            progress_pin.select('text').text(`20/${dragDate}`)
            let tmpdate = dragDate
            setTimeout(()=>{
                if(tmpdate === dragDate){
                    rayCity()
                }
            },300)
            let offY = index * 720 / (data_clean.weibo_date.length - 1)
            progress_bar.attr('height', offY)
            progress_pin.attr('transform', `translate(0 ${offY})`)
            updateBarChart(dragDate)
        }
    }, 20)
    progressLoaded('主视觉组件')
})

